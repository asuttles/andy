#+STARTUP: fold
#+TITLE: ANDY COMPILER (andyc)

ANDY COMPILER

Andy's PL/0+ to Wasm compiler written in Common Lisp.

* Original Goals
- Implement a PL/0 compiler with a real AST representation.
- Support extensions later (floats, strings, richer functions).
- Target WebAssembly, for a basic stack-based VM backend.
* References
- Wirth, Niklaus. Compiler construction. Germany: Addison-Wesley, 1996.
* Original Keywords
- const
- var
- procedure
- call
- begin
- end
- if
- then
- while
- do
* Original PL/0 EBNF
#+begin_src pascal

  program   = block "." .

  block     = [ "const" ident "=" number { "," ident "=" number } ";" ]
              [ "var" ident { "," ident } ";" ]
              { "procedure" ident ";" block ";" }
              statement .

  statement = [ ident ":=" expression
              | "call" ident
              | "begin" statement { ";" statement } "end"
              | "if" condition "then" statement
              | "while" condition "do" statement ] .

  condition = "odd" expression
             | expression ( "=" | "#" | "<" | ">" ) expression .

  expression = [ "+" | "-" ] term { ( "+" | "-" ) term } .

  term       = factor { ( "*" | "/" ) factor } .

  factor     = ident
             | number
             | "(" expression ")" .

  ident  = letter { letter | digit } .
  number = digit { digit } .
  letter = "a" | "b" | ... | "z" .
  digit  = "0" | "1" | ... | "9" .
    
#+end_src
* Andy EBNF
#+begin_src ebnf

  (* --- Lexical Elements --- *)
  letter        = "A" | ... | "Z" | "a" | ... | "z" ;
  digit         = "0" | ... | "9" ;
  identifier    = letter { letter | digit | "_" } ;
  integer       = digit { digit } ;
  float         = digit { digit } "." digit { digit } ;
  number        = float | integer ;
  string-lit    = '"' { printable-character - '"' } '"' ;
  comment       = "//" { any-character - newline } newline ;

  (* --- Program --- *)
  program       = "program" program-type block "." ;
  program-type  = "int" | "float" | "void" ;
  block         = [ constant-declarations ]
                  { variable-declaration }
                  { function-declaration }
                  statement ;

  (* --- Declarations --- *)
  constant-declarations = "const" typed-const { "," typed-const } ";" ;
  typed-const           = type identifier "=" literal ;

  variable-declaration  = type var-list ";" ;
  var-list              = var-decl { "," var-decl } ;
  var-decl              = identifier [ "[" integer "]" ] ;
  type                  = "int" | "float" | "string" ;
  literal               = number | string-lit ;

  (* --- Functions --- *)
  function-declaration  = "fun" identifier "(" [ parameter-list ] ")"
                          [ ":" type ]
                          block ";" ;
   
  parameter-list        = parameter { "," parameter } ;
  parameter             = type identifier ;

  (* --- Statements --- *)
  statement =
        assignment
      | call
      | compound-statement
      | if-statement
      | while-statement
      | for-statement
      | switch-statement
      | break-statement
      | return-statement
      | ε ;

  assignment            = identifier [ "[" expression "]" ] ":=" expression ";" ;
  call                  = identifier "(" [ argument-list ] ")" ";" ;
  argument-list         = expression { "," expression } ;

  compound-statement    = "begin" statement { statement } "end" ;
  break-statement       = "break" ";" ;
  return-statement      = "return" [ expression ] ";" ;


  (* --- Flow Control --- *)
  if-statement          = "if" condition "then" statement
                          [ "else" statement ] ;

  while-statement       = "while" condition "do" statement ;

  for-statement         = "for" "(" [ assignment ] ";"
                                   [ condition ] ";"
                                   [ assignment ] ")"
                          statement ;

  switch-statement      = "switch" "(" expression ")"
                          { case-clause }
                          [ default-clause ]
                          "end" ;

  case-clause           = "case" integer ":" { statement } ;
  default-clause        = "default" ":" { statement } ;
         

  (* --- Conditions --- *)
  condition = expression relop expression ;
  relop     = "=" | "≠" | "<" | "≤" | ">" | "≥" ;

    
  (* --- Expressions --- *)
  expression            = logical-term { ("or" | "xor") logical-term } ;
  logical-term          = logical-factor { "and" logical-factor } ;
  logical-factor        = simple-expression [ relop simple-expression ] ;

  relop                 = "=" | "≠" | "<" | "≤" | ">" | "≥" ;

  simple-expression     = term { ("+" | "-") term } ;
  term                  = factor { ("*" | "/") factor } ;

  factor                = identifier [ "[" expression "]" ]
                        | number
                        | string-lit
                        | "(" expression ")"
                        | ("+" | "-" | "not") factor ;
#+end_src
* Andy's WASM Runtime Memory Model
** Strategy

|-------------------+--------------------------------------------------------------------------------------|
| Concept           | Purpose                                                                              |
|-------------------+--------------------------------------------------------------------------------------|
| Constants         | Immutable string and numeric literals emitted by the compiler.                       |
| Globals / statics | Variables with global scope that persist across functions.                           |
| Runtime headers   | Fixed metadata for WASI syscalls (like fd_write structs, nwritten count).            |
| Runtime buffers   | Scratch areas for formatting output or temporary conversions.                        |
| Heap              | Dynamic allocations that grow upward.                                                |
| Stack             | (Optional) language-managed stack that grows downward from the top of linear memory. |
|-------------------+--------------------------------------------------------------------------------------|

** Map
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Region                     | Hex Start | Hex End | Dec Start | Dec End | Growth   | Purpose / Notes                                                              |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Constant strings / data    |    0x0000 |  0x03FF |         0 |    1023 | none     | Immutable data: string literals, "constant" values emitted by compiler.      |
| Globals / static variables |    0x0400 |  0x07FF |      1024 |    2047 | none     | Global/static vars used by all procedures. Assigned fixed offsets.           |
| Runtime headers / sys IOVs |    0x0800 |  0x08FF |      2048 |    2303 | none     | Fixed addresses for WASI fd_write structs, iovec tables, nwritten ptrs, etc. |
| Runtime buffers (scratch)  |    0x0900 |  0x0FFF |      2304 |    4095 | none     | Temporary space for print_i32, string building, etc.                         |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Heap (dynamic allocations) |    0x1000 |   ↑ ↑ ↑ |      4096 |   ↑ ↑ ↑ | upward   | Grows upward as dynamic memory is allocated (e.g., arrays, strings).         |
| Stack (language-managed)   |    0xF000 |   ↓ ↓ ↓ |     61440 |   ↓ ↓ ↓ | downward | Grows downward for local call frames or temporaries.                         |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|

* Changes from PL/0
** Stuff to Add
+ A foreach function
+ Variable-sized collection data structure  
+ Random number generator
+ Read statement
+ Command line switches
  - debug, target, listing, assembler
+ Short-circuiting logic operators for flow control?
+ 'Not' unary operator
+ Struct/Record
+ Built-In Math Operators: sqrt, int2float, float2int, abs, pow, neg, min, max, ceil, floor
+ Test negative integers and floats
+ Bounds checking for array references and assigns
*** Improved Error Messages
   1) Create a location struct with line/column properties
   2) Add location slot to the AST nodes
   3) Populate the slot when creating AST nodes in the parser
   4) Then the analyzer can access locations when raising errors.
** Stuff Added    
+ Comments
+ Integers (i32)
+ Immutable ASCII Strings
+ else
+ switch-case
+ C-Style for loops (with early break terminations)
+ logic operators: and,or,xor
+ write statement
+ Emitter indent/outdent functions to prettify printing
+ Break from while loops and switch-case statements
+ Function parameters and returns
+ Floating Point Numbers
+ Fixed=sized arrays
* Debugging in SLIME
(declaim (optimize (debug 3) (safety 3) (speed 0) (compilation-speed 0)))
* Project Structure
.
├── LICENSE
├── README.md
├── andy.asd
├── img
│   └── screenshot1.png
├── inc
│   └── io.wat
├── package.lisp
├── proj_struct.txt
├── project-notes.org
├── src
│   ├── analyzer.lisp
│   ├── ast.lisp
│   ├── emitter.lisp
│   ├── lexer.lisp
│   ├── main.lisp
│   ├── parser.lisp
│   └── runtime.lisp
└── tests
    ├── euler1.pl0
    ├── euler2.pl0
    ├── euler3.pl0
    ├── fac.pl0
    ├── fizzbuzz.pl0
    ├── string.pl0
    ├── summation.pl0
    ├── test1.pl0
    ├── test2.pl0
    └── test3.pl0
* WASM Notes
- [[https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Understanding_the_text_format][MSDN Tutorial]]
