#+STARTUP: fold
#+TITLE: ANDY COMPILER (andyc)

ANDY COMPILER

Andy's PL/0+ to Wasm compiler written in Common Lisp.

* Goals
- Implement a PL/0 compiler with a real AST representation.
- Support extensions later (floats, strings, richer functions).
- Eventually target WebAssembly, starting with a stack-based VM backend.

* References
- Wirth, Niklaus. Compiler construction. Germany: Addison-Wesley, 1996.
* Keywords
- const
- var
- procedure
- call
- begin
- end
- if
- then
- while
- do
* Original PL/0 EBNF
#+begin_src pascal

  program   = block "." .

  block     = [ "const" ident "=" number { "," ident "=" number } ";" ]
              [ "var" ident { "," ident } ";" ]
              { "procedure" ident ";" block ";" }
              statement .

  statement = [ ident ":=" expression
              | "call" ident
              | "begin" statement { ";" statement } "end"
              | "if" condition "then" statement
              | "while" condition "do" statement ] .

  condition = "odd" expression
             | expression ( "=" | "#" | "<" | ">" ) expression .

  expression = [ "+" | "-" ] term { ( "+" | "-" ) term } .

  term       = factor { ( "*" | "/" ) factor } .

  factor     = ident
             | number
             | "(" expression ")" .

  ident  = letter { letter | digit } .
  number = digit { digit } .
  letter = "a" | "b" | ... | "z" .
  digit  = "0" | "1" | ... | "9" .
    
#+end_src
* Updated PL/0+ EBNF
#+begin_src pascal

  (* --- Lexical Elements --- *)
  letter    = "A" | ... | "Z" | "a" | ... | "z" ;
  digit     = "0" | ... | "9" ;
  identifier= letter { letter | digit } ;
  number    = digit { digit } ;

  comment   = "//" { any-character - newline } newline ;

  (* --- Program --- *)
  program   = block "." ;

  block     = [ constant-declarations ]
              { variable-declaration }
              { procedure-declaration }
              statement ;

  (* --- Declarations --- *)
  constant-declarations = "const" typed-const { "," typed-const } ";" ;
  typed-const           = type identifier "=" literal ;

  variable-declaration  = type identifier { "," identifier } ";" ;
  type                  = "int" | "float" | "bool" | "string" ;
  	    
  procedure-declaration = "procedure" identifier ";" block ";" ;

  (* --- Statements --- *)
  statement = assignment
            | call
            | compound-statement
            | if-statement
            | while-statement
            | ε ;

  assignment = identifier ":=" expression ";" ;
  call       = "call" identifier ";" ;

  compound-statement = "begin" statement { statement } "end" ;

  if-statement = "if" condition "then" statement ;
  while-statement = "while" condition "do" statement ;

  (* --- Conditions --- *)
  condition = expression relop expression ;
  relop     = "=" | "≠" | "<" | "≤" | ">" | "≥" ;

  (* --- Expressions --- *)
  expression = term { ("+" | "-") term } ;
  term       = factor { ("*" | "/") factor } ;
  factor     = identifier
             | number
             | "(" expression ")"
             | ("+" | "-") factor ;   (* unary +/- *)
#+end_src
* Andy's WASM Runtime Memory Model
** Strategy

|-------------------+--------------------------------------------------------------------------------------|
| Concept           | Purpose                                                                              |
|-------------------+--------------------------------------------------------------------------------------|
| Constants         | Immutable string and numeric literals emitted by the compiler.                       |
| Globals / statics | Variables with global scope that persist across functions.                           |
| Runtime headers   | Fixed metadata for WASI syscalls (like fd_write structs, nwritten count).            |
| Runtime buffers   | Scratch areas for formatting output or temporary conversions.                        |
| Heap              | Dynamic allocations that grow upward.                                                |
| Stack             | (Optional) language-managed stack that grows downward from the top of linear memory. |
|-------------------+--------------------------------------------------------------------------------------|

** Map
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Region                     | Hex Start | Hex End | Dec Start | Dec End | Growth   | Purpose / Notes                                                              |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Constant strings / data    |    0x0000 |  0x03FF |         0 |    1023 | none     | Immutable data: string literals, "constant" values emitted by compiler.      |
| Globals / static variables |    0x0400 |  0x07FF |      1024 |    2047 | none     | Global/static vars used by all procedures. Assigned fixed offsets.           |
| Runtime headers / sys IOVs |    0x0800 |  0x08FF |      2048 |    2303 | none     | Fixed addresses for WASI fd_write structs, iovec tables, nwritten ptrs, etc. |
| Runtime buffers (scratch)  |    0x0900 |  0x0FFF |      2304 |    4095 | none     | Temporary space for print_i32, string building, etc.                         |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Heap (dynamic allocations) |    0x1000 |   ↑ ↑ ↑ |      4096 |   ↑ ↑ ↑ | upward   | Grows upward as dynamic memory is allocated (e.g., arrays, strings).         |
| Stack (language-managed)   |    0xF000 |   ↓ ↓ ↓ |     61440 |   ↓ ↓ ↓ | downward | Grows downward for local call frames or temporaries.                         |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|

* Changes from PL/0
** Stuff to Add
+ Command line switches
  - debug, target, listing, assembler
+ Floating Point Numbers
+ Short-circuiting logic operators for flow control?
+ 'Not' unary operator
+ Struct/Record
+ Read statement
+ Arrays and a foreach function
*** Improved Error Messages
   1) Create a location struct with line/column properties
   2) Add location slot to the AST nodes
   3) Populate the slot when creating AST nodes in the parser
   4) Then the analyzer can access locations when raising errors.
** Stuff Added    
+ Comments
+ Integers (i32)
+ Immutable ASCII Strings
+ else
+ switch-case
+ C-Style for loops (with early break terminations)
+ logic operators: and,or,xor
+ write statement
+ Emitter indent/outdent functions to prettify printing
+ Break from while loops and switch-case statements
+ Function parameters and returns
* Debugging in SLIME
(declaim (optimize (debug 3) (safety 3) (speed 0) (compilation-speed 0)))
* Project Structure
.
├── LICENSE
├── README.md
├── andy.asd
├── img
│   └── screenshot1.png
├── inc
│   └── io.wat
├── package.lisp
├── proj_struct.txt
├── project-notes.org
├── src
│   ├── analyzer.lisp
│   ├── ast.lisp
│   ├── emitter.lisp
│   ├── lexer.lisp
│   ├── main.lisp
│   ├── parser.lisp
│   └── runtime.lisp
└── tests
    ├── euler1.pl0
    ├── euler2.pl0
    ├── euler3.pl0
    ├── fac.pl0
    ├── fizzbuzz.pl0
    ├── string.pl0
    ├── summation.pl0
    ├── test1.pl0
    ├── test2.pl0
    └── test3.pl0
* WASM Notes
- [[https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Understanding_the_text_format][MSDN Tutorial]]
