#+STARTUP: fold
#+TITLE: ANDY COMPILER (andyc)

ANDY COMPILER

Andy's PL/0+ to Wasm compiler written in Common Lisp.

* Goals
- Implement a PL/0 compiler with a real AST representation.
- Support extensions later (floats, strings, richer functions).
- Eventually target WebAssembly, starting with a stack-based VM backend.

* References
- Wirth, Niklaus. Compiler construction. Germany: Addison-Wesley, 1996.
* Keywords
- const
- var
- procedure
- call
- begin
- end
- if
- then
- while
- do
* Original PL/0 EBNF
#+begin_src pascal

  program   = block "." .

  block     = [ "const" ident "=" number { "," ident "=" number } ";" ]
              [ "var" ident { "," ident } ";" ]
              { "procedure" ident ";" block ";" }
              statement .

  statement = [ ident ":=" expression
              | "call" ident
              | "begin" statement { ";" statement } "end"
              | "if" condition "then" statement
              | "while" condition "do" statement ] .

  condition = "odd" expression
             | expression ( "=" | "#" | "<" | ">" ) expression .

  expression = [ "+" | "-" ] term { ( "+" | "-" ) term } .

  term       = factor { ( "*" | "/" ) factor } .

  factor     = ident
             | number
             | "(" expression ")" .

  ident  = letter { letter | digit } .
  number = digit { digit } .
  letter = "a" | "b" | ... | "z" .
  digit  = "0" | "1" | ... | "9" .
    
#+end_src
* Updated PL/0+ EBNF
#+begin_src pascal

  (* --- Lexical Elements --- *)
  letter    = "A" | ... | "Z" | "a" | ... | "z" ;
  digit     = "0" | ... | "9" ;
  identifier= letter { letter | digit } ;
  number    = digit { digit } ;

  comment   = "//" { any-character - newline } newline ;

  (* --- Program --- *)
  program   = block "." ;

  block     = [ constant-declarations ]
              { variable-declaration }
              { procedure-declaration }
              statement ;

  (* --- Declarations --- *)
  constant-declarations = "const" typed-const { "," typed-const } ";" ;
  typed-const           = type identifier "=" literal ;

  variable-declaration  = type identifier { "," identifier } ";" ;
  type                  = "int" | "float" | "bool" | "string" ;
  	    
  procedure-declaration = "procedure" identifier ";" block ";" ;

  (* --- Statements --- *)
  statement = assignment
            | call
            | compound-statement
            | if-statement
            | while-statement
            | ε ;

  assignment = identifier ":=" expression ";" ;
  call       = "call" identifier ";" ;

  compound-statement = "begin" statement { statement } "end" ;

  if-statement = "if" condition "then" statement ;
  while-statement = "while" condition "do" statement ;

  (* --- Conditions --- *)
  condition = expression relop expression ;
  relop     = "=" | "≠" | "<" | "≤" | ">" | "≥" ;

  (* --- Expressions --- *)
  expression = term { ("+" | "-") term } ;
  term       = factor { ("*" | "/") factor } ;
  factor     = identifier
             | number
             | "(" expression ")"
             | ("+" | "-") factor ;   (* unary +/- *)
#+end_src
* Memory Map
  Total Memory 64K
  - Program Data    =   0 to  99 bytes
  - Scratch Data    = 100 to 199 bytes  (scratch data, IO, etc)
  - System Scratch  = 200 to 299 bytes  (bytes read, etc)
  - IOVec Structure = 300 to 307 bytes  (WASI uses)
  - Free            = 400 to 65k  
* Roadmap
*** DONE Step 0: Project layout
- Create directory structure:
  #+begin_src
  andy/
    src/
      lexer.lisp
      parser.lisp
      ast.lisp
      symbol.lisp
      emit.lisp
      vm.lisp
      main.lisp
    tests/
    examples/
    andy.asd
    package.lisp
    README.md
  #+end_src

*** DONE Step 1: Define tokens
- Represent tokens as (TYPE . VALUE).
- Types include keywords, identifiers, numbers, operators, punctuation.
- Example:
  #+begin_src lisp
  (cons :IDENT "x")
  (cons :NUMBER 42)
  #+end_src

*** DONE Step 2: Lexer
- Implement =tokenize= function.
- Handle identifiers/keywords, numbers, symbols, := operator, etc.
- Store line/col for error reporting.

*** DONE Step 3: AST design
- Decide AST node forms: use structs or CLOS classes.
- Examples:
  - Program, Block, Statement, Expression nodes.
- Benefit: easier to expand to floats, strings, or richer type system later.

*** DONE Step 4: Parser (recursive descent)
- Functions mirror grammar:
  - =parse-program=
  - =parse-block=
  - =parse-statement=
  - =parse-condition=
  - =parse-expression=
  - =parse-term=
  - =parse-factor=
- For now, parser builds AST instead of directly emitting code.

*** DONE Step 5: Symbol table
- Maintain a table with entries:
  | name | kind (const/var/proc) | value | level | address |
- Functions: =enter-const=, =enter-var=, =enter-proc=, =find-symbol=.

*** DONE Step 6: Semantic Analysis
*** TODO Step 6: Code emission
- Map stack instructions to WASM text (=.wat=).
- Strategy A: compile each PL/0 procedure to a WASM function with locals.
- Strategy B: direct WASM emission with structured control flow.
- Begin by restricting nested procedures for simpler mapping.
*** TODO Step 9: Testing plan
*** TODO Step 10: Improved Error handling
- Lexer tracks positions.
- Parser raises syntax errors with expected vs. actual token.

*** TODO Step 11: Extensions (later)
- Functions with return values.
- Typed variables (int, float).
- Floating point arithmetic.
- Strings and simple heap management.
- Arrays and records.

* Stuff to Add
+ Pretty-printer
+ Command line switches
  - debug, target, listing, assembler
+ DONE - Comments
+ Function parameters
+ Types:
  + Floats (i64)
  + Integers (i32)
  + +Booleans+
  + Strings
+ elseif
+ logic operators (and,or,xor)
  where, 0 = false; everything else = true 
+ I/O (read, write)
+ Arrays
+ for loops?  (maybe as a macro?)
+ switch statements (maybe as a macro?)
** Improved Error Messages
   1) Create a location struct with line/column properties
   2) Add location slot to the AST nodes
   3) Populate the slot when creating AST nodes in the parser
   4) Then the analyzer can access locations when raising errors.
* Project Structure
.
├── LICENSE
├── README.md
├── andy.asd
├── img
│   └── screenshot1.png
├── package.lisp
├── project-notes.org
├── runtime
│   ├── io.wasm
│   └── io.wat
├── src
│   ├── analyzer.lisp
│   ├── ast.lisp
│   ├── lexer.lisp
│   ├── main.lisp
│   ├── parser.lisp
│   └── wasm.lisp
└── tests
    └── test1.pl0
* WASM Notes
- [[https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Understanding_the_text_format][MSDN Tutorial]]
