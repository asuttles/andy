#+STARTUP: fold
#+TITLE: ANDY COMPILER (andyc)

ANDY COMPILER

Andy's PL/0+ to Wasm compiler written in Common Lisp.

* Goals
- Implement a PL/0 compiler with a real AST representation.
- Support extensions later (floats, strings, richer functions).
- Eventually target WebAssembly, starting with a stack-based VM backend.

* References
- Wirth, Niklaus. Compiler construction. Germany: Addison-Wesley, 1996.
* Keywords
- const
- var
- procedure
- call
- begin
- end
- if
- then
- while
- do
* Original PL/0 EBNF
#+begin_src pascal

  program   = block "." .

  block     = [ "const" ident "=" number { "," ident "=" number } ";" ]
              [ "var" ident { "," ident } ";" ]
              { "procedure" ident ";" block ";" }
              statement .

  statement = [ ident ":=" expression
              | "call" ident
              | "begin" statement { ";" statement } "end"
              | "if" condition "then" statement
              | "while" condition "do" statement ] .

  condition = "odd" expression
             | expression ( "=" | "#" | "<" | ">" ) expression .

  expression = [ "+" | "-" ] term { ( "+" | "-" ) term } .

  term       = factor { ( "*" | "/" ) factor } .

  factor     = ident
             | number
             | "(" expression ")" .

  ident  = letter { letter | digit } .
  number = digit { digit } .
  letter = "a" | "b" | ... | "z" .
  digit  = "0" | "1" | ... | "9" .
    
#+end_src
* Updated PL/0+ EBNF
#+begin_src pascal

  (* --- Lexical Elements --- *)
  letter    = "A" | ... | "Z" | "a" | ... | "z" ;
  digit     = "0" | ... | "9" ;
  identifier= letter { letter | digit } ;
  number    = digit { digit } ;

  comment   = "//" { any-character - newline } newline ;

  (* --- Program --- *)
  program   = block "." ;

  block     = [ constant-declarations ]
              { variable-declaration }
              { procedure-declaration }
              statement ;

  (* --- Declarations --- *)
  constant-declarations = "const" typed-const { "," typed-const } ";" ;
  typed-const           = type identifier "=" literal ;

  variable-declaration  = type identifier { "," identifier } ";" ;
  type                  = "int" | "float" | "bool" | "string" ;
  	    
  procedure-declaration = "procedure" identifier ";" block ";" ;

  (* --- Statements --- *)
  statement = assignment
            | call
            | compound-statement
            | if-statement
            | while-statement
            | ε ;

  assignment = identifier ":=" expression ";" ;
  call       = "call" identifier ";" ;

  compound-statement = "begin" statement { statement } "end" ;

  if-statement = "if" condition "then" statement ;
  while-statement = "while" condition "do" statement ;

  (* --- Conditions --- *)
  condition = expression relop expression ;
  relop     = "=" | "≠" | "<" | "≤" | ">" | "≥" ;

  (* --- Expressions --- *)
  expression = term { ("+" | "-") term } ;
  term       = factor { ("*" | "/") factor } ;
  factor     = identifier
             | number
             | "(" expression ")"
             | ("+" | "-") factor ;   (* unary +/- *)
#+end_src
* Andy's WASM Runtime Memory Model
** Strategy

|-------------------+--------------------------------------------------------------------------------------|
| Concept           | Purpose                                                                              |
|-------------------+--------------------------------------------------------------------------------------|
| Constants         | Immutable string and numeric literals emitted by the compiler.                       |
| Globals / statics | Variables with global scope that persist across functions.                           |
| Runtime headers   | Fixed metadata for WASI syscalls (like fd_write structs, nwritten count).            |
| Runtime buffers   | Scratch areas for formatting output or temporary conversions.                        |
| Heap              | Dynamic allocations that grow upward.                                                |
| Stack             | (Optional) language-managed stack that grows downward from the top of linear memory. |
|-------------------+--------------------------------------------------------------------------------------|

** Map
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Region                     | Hex Start | Hex End | Dec Start | Dec End | Growth   | Purpose / Notes                                                              |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Constant strings / data    |    0x0000 |  0x03FF |         0 |    1023 | none     | Immutable data: string literals, "constant" values emitted by compiler.      |
| Globals / static variables |    0x0400 |  0x07FF |      1024 |    2047 | none     | Global/static vars used by all procedures. Assigned fixed offsets.           |
| Runtime headers / sys IOVs |    0x0800 |  0x08FF |      2048 |    2303 | none     | Fixed addresses for WASI fd_write structs, iovec tables, nwritten ptrs, etc. |
| Runtime buffers (scratch)  |    0x0900 |  0x0FFF |      2304 |    4095 | none     | Temporary space for print_i32, string building, etc.                         |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|
| Heap (dynamic allocations) |    0x1000 |   ↑ ↑ ↑ |      4096 |   ↑ ↑ ↑ | upward   | Grows upward as dynamic memory is allocated (e.g., arrays, strings).         |
| Stack (language-managed)   |    0xF000 |   ↓ ↓ ↓ |     61440 |   ↓ ↓ ↓ | downward | Grows downward for local call frames or temporaries.                         |
|----------------------------+-----------+---------+-----------+---------+----------+------------------------------------------------------------------------------|

* Stuff to Add
+ Emitter coud use an (indent) function that controls spacing
+ Pretty-printer (for debugging)
+ Command line switches
  - debug, target, listing, assembler
+ +DONE - Comments+
+ Function parameters
+ Function returns  
+ Types:
  + Floats (i64)
  + +DONE Integers (i32)+
  + +Booleans+
  + +DONE Non-mutable ASCII Strings+
+ +DONE elseif+
+ +DONE logic operators (and,or,xor)+
+ Short-circuiting logic operators for flow control
+ 'Not' unary operator
+ Struct/Record
+ I/O (read, +DONE write+)
+ Arrays and a map or foreach function
+ for loops?  (maybe as a macro?)
+ switch statements (maybe as a macro?)
** Improved Error Messages
   1) Create a location struct with line/column properties
   2) Add location slot to the AST nodes
   3) Populate the slot when creating AST nodes in the parser
   4) Then the analyzer can access locations when raising errors.
* Project Structure
.
├── LICENSE
├── README.md
├── andy.asd
├── img
│   └── screenshot1.png
├── package.lisp
├── project-notes.org
├── runtime
│   ├── io.wasm
│   └── io.wat
├── src
│   ├── analyzer.lisp
│   ├── ast.lisp
│   ├── lexer.lisp
│   ├── main.lisp
│   ├── parser.lisp
│   └── wasm.lisp
└── tests
    └── test1.pl0
* WASM Notes
- [[https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Understanding_the_text_format][MSDN Tutorial]]
