#+STARTUP: fold
#+TITLE: ANDY COMPILER (andyc)

ANDY COMPILER

Andy's PL/0+ to Wasm compiler written in Common Lisp.

* Goals
- Implement a PL/0 compiler with a real AST representation.
- Support extensions later (floats, strings, richer functions).
- Eventually target WebAssembly, starting with a stack-based VM backend.

* References
- Wirth, Niklaus. Compiler construction. Germany: Addison-Wesley, 1996.
* Keywords
- const
- var
- procedure
- call
- begin
- end
- if
- then
- while
- do
* Original PL/0 EBNF
#+begin_src pascal

  program   = block "." .

  block     = [ "const" ident "=" number { "," ident "=" number } ";" ]
              [ "var" ident { "," ident } ";" ]
              { "procedure" ident ";" block ";" }
              statement .

  statement = [ ident ":=" expression
              | "call" ident
              | "begin" statement { ";" statement } "end"
              | "if" condition "then" statement
              | "while" condition "do" statement ] .

  condition = "odd" expression
             | expression ( "=" | "#" | "<" | ">" ) expression .

  expression = [ "+" | "-" ] term { ( "+" | "-" ) term } .

  term       = factor { ( "*" | "/" ) factor } .

  factor     = ident
             | number
             | "(" expression ")" .

  ident  = letter { letter | digit } .
  number = digit { digit } .
  letter = "a" | "b" | ... | "z" .
  digit  = "0" | "1" | ... | "9" .
    
#+end_src
* Updated PL/0+ EBNF
(* --- Lexical Elements --- *)
letter    = "A" | ... | "Z" | "a" | ... | "z" ;
digit     = "0" | ... | "9" ;
identifier= letter { letter | digit } ;
number    = digit { digit } ;

comment   = "//" { any-character - newline } newline ;

(* --- Program --- *)
program   = block "." ;

block     = [ constant-declarations ]
            { variable-declaration }
            { procedure-declaration }
            statement ;

(* --- Declarations --- *)
constant-declarations = "const" typed-const { "," typed-const } ";" ;
typed-const           = type identifier "=" literal ;

variable-declaration  = type identifier { "," identifier } ";" ;
type                  = "int" | "float" | "bool" | "string" ;
	    
procedure-declaration = "procedure" identifier ";" block ";" ;

(* --- Statements --- *)
statement = assignment
          | call
          | compound-statement
          | if-statement
          | while-statement
          | ε ;

assignment = identifier ":=" expression ";" ;
call       = "call" identifier ";" ;

compound-statement = "begin" statement { statement } "end" ;

if-statement = "if" condition "then" statement ;
while-statement = "while" condition "do" statement ;

(* --- Conditions --- *)
condition = expression relop expression ;
relop     = "=" | "≠" | "<" | "≤" | ">" | "≥" ;

(* --- Expressions --- *)
expression = term { ("+" | "-") term } ;
term       = factor { ("*" | "/") factor } ;
factor     = identifier
           | number
           | "(" expression ")"
           | ("+" | "-") factor ;   (* unary +/- *)
* Roadmap
*** DONE Step 0: Project layout
- Create directory structure:
  #+begin_src
  andy/
    src/
      lexer.lisp
      parser.lisp
      ast.lisp
      symbol.lisp
      emit.lisp
      vm.lisp
      main.lisp
    tests/
    examples/
    andy.asd
    package.lisp
    README.md
  #+end_src

*** DONE Step 1: Define tokens
- Represent tokens as (TYPE . VALUE).
- Types include keywords, identifiers, numbers, operators, punctuation.
- Example:
  #+begin_src lisp
  (cons :IDENT "x")
  (cons :NUMBER 42)
  #+end_src

*** DONE Step 2: Lexer
- Implement =tokenize= function.
- Handle identifiers/keywords, numbers, symbols, := operator, etc.
- Store line/col for error reporting.

*** DONE Step 3: AST design
- Decide AST node forms: use structs or CLOS classes.
- Examples:
  - Program, Block, Statement, Expression nodes.
- Benefit: easier to expand to floats, strings, or richer type system later.

*** DONE Step 4: Parser (recursive descent)
- Functions mirror grammar:
  - =parse-program=
  - =parse-block=
  - =parse-statement=
  - =parse-condition=
  - =parse-expression=
  - =parse-term=
  - =parse-factor=
- For now, parser builds AST instead of directly emitting code.

*** TODO Step 5: Symbol table
- Maintain a table with entries:
  | name | kind (const/var/proc) | value | level | address |
- Functions: =enter-const=, =enter-var=, =enter-proc=, =find-symbol=.

*** TODO Step 6: Code emission
- Instruction format: (OP L M).
- Opcodes:
  - LIT, OPR, LOD, STO, CAL, INT, JMP, JPC
- OPR subcodes: RET, ADD, SUB, MUL, DIV, etc.
- Implement =emit= function to build code vector.

*** TODO Step 7: Virtual Machine
- State: pc, bp, sp, stack array.
- Implement =base= function for static link resolution.
- =run-vm= executes emitted code.
- First backend for quick testing.

*** TODO Step 8: Codegen from AST
- Walk AST and emit stack-machine instructions.
- Examples:
  - Assignment: generate expr code, then STO.
  - If: condition + JPC + stmt + backpatch.
  - While: loop label, cond, body, jumps.

*** TODO Step 9: Testing plan
- Minimal program: =begin end.=
- Assignments and arithmetic.
- Procedure call.
- Factorial program.
- Write harness in =tests/= that:
  - Reads example file.
  - Tokenizes, parses, builds AST.
  - Emits and prints code.
  - Runs VM.

*** TODO Step 10: Error handling
- Lexer tracks positions.
- Parser raises syntax errors with expected vs. actual token.

*** TODO Step 11: Extensions (later)
- Functions with return values.
- Typed variables (int, float).
- Floating point arithmetic.
- Strings and simple heap management.
- Arrays and records.

*** TODO Step 12: WASM backend
- Map stack instructions to WASM text (=.wat=).
- Strategy A: compile each PL/0 procedure to a WASM function with locals.
- Strategy B: direct WASM emission with structured control flow.
- Begin by restricting nested procedures for simpler mapping.

* Stuff to Add
+ Pretty-printer
+ Command line switches
  - debug, target, listing, assembler
+ DONE - Comments
+ Function parameters
+ Types:
  + Floats (i64)
  + Integers (i32)
  + Booleans 
+ Local Variables
+ logic operators (and,or,xor)  
+ I/O
+ Arrays
+ for loops
+ switch statements
+ Strings
* WASM Notes
- [[https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Understanding_the_text_format][MSDN Tutorial]]
